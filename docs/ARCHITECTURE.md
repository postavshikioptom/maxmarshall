# Архитектура Сайта Блога Max Marhsall. Посты берет из Github Multiverse, а зедсь только две страницы
1. Project Vision

A minimalist, high-performance static blog that mimics the UX/UI of X.com (Twitter). It is a "child" site designed to consume static assets (HTML/JSON) generated by a CMS like Decap CMS.
2. Technical Requirements

    Language: HTML5, CSS3, Vanilla JavaScript (ES6+).
    Style: Dark mode by default (#000000 background).
    Responsive: Mobile-first approach with breakpoints at 768px and 1024px.
    Data Source: Fetching from /posts/ directory and a posts.json index.

3. Implementation Roadmap
Phase 1: Core Layout & Shell (HTML/CSS)

    1.1. CSS Variable Definitions: Setup colors (--bg: #000, --surface: #121212, --accent: #1d9bf0, --border: #2f3336).
    1.2. Global Reset & Typography: Implement a clean sans-serif stack (Inter/System-fonts).
    1.3. Header Component: Create a fixed top bar with a glass effect (backdrop-filter: blur) and the "X-Blog" logo.
    1.4. Sidebar Components:
        Left (Nav): Vertical menu with icons for Home, Explore, and Profile.
        Right (Widgets): "Latest Posts" and "Categories" panels with border-radius and high-contrast text.
    1.5. Feed Container: A central scrollable area with a max-width of 600px-700px to maintain the "timeline" feel.

Phase 2: Dynamic Content Engine (JavaScript)

    2.1. Content Fetcher: Create a function to fetch() the posts.json index file on page load.
    2.2. Template Engine: Build a JS function that converts JSON post data into the "Tweet-style" card HTML seen in the design.
    2.3. Article View Logic:
        Use URLSearchParams or window.location.hash to detect when a user clicks a post.
        Create a "View Switcher" that hides the feed and shows the full article content dynamically.
    2.4. Search Functionality: Implement a real-time filter that listens to the header input and filters the displayed cards by title or tags.
    2.5. Infinite Loading: Add a "Show more" button or Intersection Observer to append the next 10 posts from the array.

Phase 3: Post Page & Social Features

    3.1. Detailed Post Layout: Render full markdown/HTML content with clear headers and image placeholders.
    3.2. Social Actions Bar: Functional JS to copy the post link to the clipboard and share to X/Twitter.
    3.3. Placeholder Comments: A minimalist, non-functional UI section for engagement metrics (likes/replies) to match the social vibe.

Phase 4: CMS & Deployment Preparation

    4.1. Decap CMS Config: Create admin/config.yml to define fields (title, date, excerpt, image, body).
    4.2. Folder Structure:
        /index.html (The main application)
        /styles.css
        /app.js
        /posts/ (Where individual post JSON/HTML files will live)
        /admin/ (Decap CMS entry point)
    4.3. Assets: Placeholder logic for images (using Unsplash IDs or local uploads).

The architecture is now fully defined. This plan ensures that the "child" site remains lightweight and fast while providing a modern, app-like experience.

=======
Да, сгенерированный мною выше код уже содержит обе страницы (и главную ленту Home, и страницу статьи Article) внутри одного HTML-файла.
Как это работает в коде:

    Два вида в одном: В блоке <body> есть два основных контейнера: <div id="feed-view"> (для ленты) и <div id="article-view"> (для самой статьи).
    Переключение без перезагрузки: JavaScript-функции viewArticle(id) и showFeed() мгновенно скрывают один блок и показывают другой. Это создает ощущение работы полноценного веб-приложения (SPA), как сам X.com.
    Динамическое наполнение: Когда вы нажимаете на карточку поста в ленте, скрипт берет данные этого поста и мгновенно "рисует" страницу статьи внутри контейнера #article-body.

Почему это удобно?

    Скорость: Переключение между лентой и статьей происходит мгновенно, так как браузеру не нужно загружать новую страницу с сервера.
    Простота: Вам нужно управлять только одним файлом index.html.
    Дизайн: Весь CSS-код (стили для ленты и для текста статьи) уже находится внутри тега <style>, поэтому обе части выглядят одинаково стильно в темной теме.

Что нужно сделать дальше?
===========
# ФАЗА 2: Код подгурзки постов с Decamp CMS

Этот план предназначен для другой AI-модели кодера (например, GitHub Copilot, Cursor или подобной), чтобы реализовать динамическую подгрузку постов из Decap CMS GitHub-repo (https://github.com/postavshikioptom/multiverse_decapcms) в репозитории дочернего сайта (https://github.com/postavshikioptom/maxmarshall). План основан на анализе структуры repo: файлы index.html (главная страница с лентой постов), post.html (шаблон детального поста), post-1-тестовый сгенерировал.html (пример сгенерированного поста), .gitignore и папка docs (возможно, для документации). Нет отдельных CSS/JS-файлов — всё inline в HTML.

**Общая Архитектура**:
- **Client-side rendering**: Vanilla JS (без фреймворков, библиотек или npm) fetch'ит посты из GitHub API/raw файлов Decap CMS. Нет сервера/BД на под-сайте — всё статическое.
- **Данные постов**: Из /content/posts/ в Decap repo. Каждый пост — .md файл с frontmatter (title, description, date, media, body, slug, target_site).
- **Фильтр**: Только посты с target_site = 'maxmarshall' (из frontmatter).
- **Главная (index.html)**: Лента последних 50 постов (превью-карточки, как в твоём sample data). Сохранить прокрутку (если имеется infinite scroll или простая прокрутка — адаптировать).
- **Детальный пост (post.html)**: По URL post.html?slug=moy-slug (или #slug=moy-slug для hash-routing). JS заменяет статический контент внутри <div class="mb-6"> и <article class="article-content"> на динамический из GitHub. Новый пост из CMS автоматически появляется по новому slug (без создания новых файлов — один post.html для всех).
- **URL/slug**: Из поля slug в frontmatter (как настроено в config.yml Decap). Читаемые URL: maxmarshall.indevs.in/post.html?slug=moy-chitayemyy-url.
- **Markdown**: Body — Markdown, парсить в HTML с marked.js (CDN).
- **Ошибки**: Обработать 404, loading states.
- **SEO/Производительность**: Добавить meta-теги динамически; кэш в localStorage для оффлайн/скорости.

**Предположения**:
- Decap config.yml настроен с полями: slug, title, description, date, media (image/video), body (markdown), target_site.
- Под-сайт на shared хостинге (FTP-загрузка файлов).
- Тестировать в браузере (F12 console для ошибок).

**Инструменты для кодера**: Vanilla JS, fetch API, RegExp для parse frontmatter. CDN для marked.js (Markdown → HTML). Нет npm.

[ ] Задача 1: Общие Подготовительные Изменения (Для Обоих Файлов)
Подзадача 1.1: Добавить CDN для marked.js (в <head> обоих HTML).
   - Вставить: `<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>`.
   - Почему: Для парсинга body (Markdown → HTML).

[ ]Подзадача 1.2: Создать общую JS-функцию loadPosts() (в <script> в конце <body> обоих файлов).
   - Это асинхронная функция для fetch списка постов и parse.
   - Код:
     ```js
     const REPO = 'postavshikioptom/multiverse_decapcms';
     const BRANCH = 'main';
     const POSTS_FOLDER = 'content/posts';
     const TARGET_SITE = 'maxmarshall';  // Фикс для этого сайта

     async function loadPosts() {
       const listUrl = `https://api.github.com/repos/${REPO}/contents/${POSTS_FOLDER}?ref=${BRANCH}`;
       const response = await fetch(listUrl, { headers: { 'Accept': 'application/vnd.github.v3+json' } });
       if (!response.ok) {
         console.error('Ошибка fetch списка:', response.status);
         return [];
       }
       const files = await response.json();

       const posts = [];
       for (const file of files) {
         if (file.name.endsWith('.md')) {
           const rawUrl = file.download_url;
           const text = await fetch(rawUrl).then(res => res.text());

           const frontmatterMatch = text.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
           if (frontmatterMatch) {
             const fm = {};
             frontmatterMatch[1].split('\n').forEach(line => {
               const [key, ...value] = line.split(': ');
               if (key) fm[key.trim()] = value.join(': ').trim().replace(/^["']|["']$/g, '');
             });
             if (fm.target_site === TARGET_SITE) {
               posts.push({
                 title: fm.title || 'Без заголовка',
                 description: fm.description || '',
                 date: new Date(fm.date || '2026-01-01'),
                 slug: fm.slug || file.name.replace('.md', ''),
                 media: fm.media || '',
                 body: marked.parse(frontmatterMatch[2].trim())  // Markdown → HTML
               });
             }
           }
         }
       }
       posts.sort((a, b) => b.date - a.date);  // Новые сверху
       return posts;
     }
     ```
   - Обработка: Если >50 постов — fetch все, но рендерить первые 50 (для главной).

[ ]Подзадача 1.3: Добавить функцию loadSinglePost(slug) (в <script> обоих файлов).
   - Для детального поста по slug.
   - Код:
     ```js
     async function loadSinglePost(slug) {
       const posts = await loadPosts();
       return posts.find(post => post.slug === slug) || null;
     }
     ```
   - Обработка ошибок: Если не найден — показать "Пост не найден".

[ ]Подзадача 1.4: Кэширование (опционально, добавить в loadPosts).
   - Использовать localStorage для ежедневного кэша (чтобы не ддосить GitHub).
   - Код в loadPosts перед fetch:
     ```js
     const cacheKey = 'posts_cache';
     const cached = localStorage.getItem(cacheKey);
     if (cached) {
       const { data, timestamp } = JSON.parse(cached);
       if (Date.now() - timestamp < 86400000) {  // 24 часа
         return data;
       }
     }
     // ... fetch ...
     localStorage.setItem(cacheKey, JSON.stringify({ data: posts, timestamp: Date.now() }));
     ```

[ ] Задача 2: Изменения в index.html (Главная — Лента Постов)
Подзадача 2.1: Заменить статический блок <script> с const posts = [...] на динамический.
   - Найти: Строчки с // Sample Post Data const posts = [ ... ] и весь массив.
   - Заменить на: 
     ```js
     async function renderPosts() {
       const posts = await loadPosts();
       const feed = document.getElementById('feed-view');  // Предполагаемый ID ленты, если нет — добавить <div id="feed-view"> вокруг карточек
       if (posts.length === 0) {
         feed.innerHTML = '<p class="text-slate-500">Нет постов</p>';
         return;
       }

       // Рендер первых 50 (или всех, если <50)
       const limitedPosts = posts.slice(0, 50);
       feed.innerHTML = limitedPosts.map(post => `
         <div class="post-card">  <!-- Твой шаблон карточки, адаптируй -->
           <h2><a href="post.html?slug=${post.slug}" onclick="return false;">${post.title}</a></h2>  <!-- Клик — открыть в post.html -->
           <p>${post.description}</p>
           <small>Дата: ${post.date.toLocaleDateString('ru-RU')}</small>
           ${post.media ? `<img src="${post.media}" alt="Media">` : ''}
         </div>
       `).join('');

       // Сохранить прокрутку: Если был infinite scroll — добавить IntersectionObserver для подгрузки следующих 50 (если >50).
       // Пример простого infinite (если нужно):
       const observer = new IntersectionObserver(entries => {
         if (entries[0].isIntersecting && limitedPosts.length < posts.length) {
           // Добавить следующие 50
         }
       });
       observer.observe(document.querySelector('.last-post'));  // Добавь class="last-post" последней карточке
     }

     window.addEventListener('load', renderPosts);
     ```
   - Сохранить прокрутку: Если оригинал имел scroll (вероятно, overflow-y: auto) — оставить CSS. Добавить lazy-loading для >50.

[ ]Подзадача 2.2: Добавить обработку клика на пост (для открытия в post.html).
   - В шаблоне карточки: <a href="post.html?slug=${post.slug}"> (или использовать onclick для hash-routing, если не хочешь отдельную страницу).

[ ]Подзадача 2.3: Добавить loading state.
   - Перед feed: <p id="loading">Загрузка постов...</p>
   - В JS: Скрыть после render.

[ ] Задача 3: Изменения в post.html (Детальный Пост)
[ ]Подзадача 3.1: Заменить статический контент внутри <div class="mb-6"> и <article class="article-content"> на динамический.
   - Найти: <div class="mb-6"> с <h1> и <p> (title/description).
   - Заменить на: <div id="post-header" class="mb-6"><p>Загрузка...</p></div>
   - Найти: <article class="article-content"> с <p>, <h2> и т.д.
   - Заменить на: <article id="post-content" class="article-content"><p>Загрузка...</p></article>
   - Убрать статический featured image: Заменить на <div id="featured-image"></div>

[ ]Подзадача 3.2: Добавить JS для fetch по slug из URL.
   - В <script> в конце <body>:
     ```js
     // Получить slug из URL (?slug=...)
     const params = new URLSearchParams(window.location.search);
     const slug = params.get('slug');

     async function renderPost() {
       if (!slug) {
         document.getElementById('post-content').innerHTML = '<p>Пост не найден</p>';
         return;
       }

       const post = await loadSinglePost(slug);
       if (!post) {
         document.getElementById('post-content').innerHTML = '<p>Пост не найден</p>';
         return;
       }

       // Заголовок и описание
       document.getElementById('post-header').innerHTML = `
         <h1 class="text-3xl md:text-4xl font-black leading-tight tracking-tight text-slate-900 dark:text-white mb-4">
           ${post.title}
         </h1>
         <p class="text-lg text-slate-500 dark:text-slate-400 font-normal">${post.description}</p>
       `;

       // Featured image, если есть
       document.getElementById('featured-image').innerHTML = post.media ? `
         <div class="w-full aspect-[16/9] rounded-xl bg-center bg-no-repeat bg-cover mb-8 border border-border-dark" style="background-image: url('${post.media}')"></div>
       ` : '';

       // Контент (HTML из Markdown)
       document.getElementById('post-content').innerHTML = post.body;
     }

     window.addEventListener('load', renderPost);
     ```
   - Это заменит только контент — остальная вёрстка (хедер, сайдбар, футер, социальные кнопки) остаётся нетронутой.

[ ]Подзадача 3.3: Добавить кнопку "Назад на главную".
   - В конец <article>: <button onclick="window.location.href='/'">← На главную</button>

[ ]Подзадача 3.4: Обработка media (фото/видео).
   - Если media — video URL, рендерить <video src="${post.media}"></video> вместо img.

[ ] Задача 4: Тестирование и Деплой
[ ]Подзадача 4.1: Тест локально (открыть HTML в браузере).
   - Создать тестовый пост в Decap с slug='test-post', target_site='maxmarshall'.
   - Проверить: index.html показывает в ленте; post.html?slug=test-post рендерит детальный.

[ ]Подзадача 4.2: Деплой на хостинг (FTP).
   - Загрузить обновлённые index.html и post.html.
   - Проверить URL: maxmarshall.indevs.in/post.html?slug=...

[ ]Подзадача 4.3: Оптимизации.
   - Rate limits GitHub: Добавить auth token, если частые fetch (headers: { Authorization: 'token YOUR_GITHUB_TOKEN' }).
   - SEO: Добавить <meta name="description" content="${post.description}"> динамически в JS (document.querySelector('meta[name="description"]').content = ...). 

Этот план полный — реализуй по шагам. Если ошибки — логи в console.

